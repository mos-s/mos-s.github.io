{"version":3,"sources":["webpack:///../../../../sourceES6/core/Meshes/Builders/sphereBuilder.ts","webpack:///../../../sourceES6/core/Meshes/groundMesh.ts","webpack:///../../../../sourceES6/core/Meshes/Builders/groundBuilder.ts"],"names":["CreateSphere","options","segments","diameterX","diameter","diameterY","diameterZ","arc","slice","sideOrientation","DEFAULTSIDE","dedupTopBottomIndices","radius","totalZRotationSteps","totalYRotationSteps","indices","positions","normals","uvs","zRotationStep","normalizedZ","angleZ","Math","PI","yRotationStep","normalizedY","angleY","rotationZ","RotationZ","rotationY","RotationY","afterRotZ","TransformCoordinates","Up","complete","vertex","multiply","normal","divide","normalize","push","x","y","z","verticesCount","length","firstIndex","_ComputeSides","frontUVs","backUVs","vertexData","name","scene","updatable","SphereBuilder","sphere","_GetDefaultSideOrientation","_originalBuilderSideOrientation","applyToMesh","_GroundMeshParser","parsedMesh","Parse","generateOctree","getClassName","min","this","_subdivisionsX","_subdivisionsY","optimize","chunksCount","octreeBlocksSize","subdivide","createOrUpdateSubmeshesOctree","getHeightAtCoordinates","world","getWorldMatrix","invMat","Matrix","invertToRef","tmpVect","Vector3","TransformCoordinatesFromFloatsToRef","_minX","_maxX","_minZ","_maxZ","position","_heightQuads","_initHeightQuads","_computeHeightQuads","facet","_getFacetAt","w","getNormalAtCoordinates","getNormalAtCoordinatesToRef","ref","tmpMat","TransformNormalFromFloatsToRef","updateCoordinateHeights","col","floor","_width","row","_height","quad","slope","facet1","facet2","subdivisionsX","subdivisionsY","Array","Zero","getVerticesData","PositionKind","v1","v2","v3","v4","v1v2","v1v3","v1v4","norm1","norm2","i","j","k","cd","h","d1","d2","subtractToRef","CrossToRef","copyFromFloats","serialize","serializationObject","minX","maxX","minZ","maxZ","width","height","result","GroundMesh","CreateGround","subdivisions","CreateTiledGround","tileRow","tileCol","xmin","undefined","zmin","xmax","zmax","precision","tileSize","applyTile","xTileMin","zTileMin","xTileMax","zTileMax","base","rowLength","square","CreateGroundFromHeightMap","filter","colorFilter","alphaFilter","invert","minHeight","maxHeight","temp","pos","bufferWidth","bufferHeight","r","buffer","g","b","a","gradient","idx1","idx2","idx3","idx4","isVisibleIdx1","isVisibleIdx2","isVisibleIdx3","ComputeNormals","url","onReady","ground","_setReady","tiledGround","LastCreatedScene","LoadImage","img","context","CreateCanvas","getContext","Error","isDisposed","drawImage","getImageData","data","offlineProvider"],"mappings":"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","file":"js/1.babylonBundle.js","sourcesContent":["import { Vector4, Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Nullable } from '../../types';\r\n\r\nVertexData.CreateSphere = function(options: { segments?: number, diameter?: number, diameterX?: number, diameterY?: number, diameterZ?: number, arc?: number, slice?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, dedupTopBottomIndices?: boolean }): VertexData {\r\n    var segments: number = options.segments || 32;\r\n    var diameterX: number = options.diameterX || options.diameter || 1;\r\n    var diameterY: number = options.diameterY || options.diameter || 1;\r\n    var diameterZ: number = options.diameterZ || options.diameter || 1;\r\n    var arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    var slice: number = options.slice && (options.slice <= 0) ? 1.0 : options.slice || 1.0;\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    var dedupTopBottomIndices = !!options.dedupTopBottomIndices;\r\n\r\n    var radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);\r\n\r\n    var totalZRotationSteps = 2 + segments;\r\n    var totalYRotationSteps = 2 * totalZRotationSteps;\r\n\r\n    var indices = [];\r\n    var positions = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n\r\n    for (var zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\r\n        var normalizedZ = zRotationStep / totalZRotationSteps;\r\n        var angleZ = normalizedZ * Math.PI * slice;\r\n\r\n        for (var yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\r\n            var normalizedY = yRotationStep / totalYRotationSteps;\r\n\r\n            var angleY = normalizedY * Math.PI * 2 * arc;\r\n\r\n            var rotationZ = Matrix.RotationZ(-angleZ);\r\n            var rotationY = Matrix.RotationY(angleY);\r\n            var afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);\r\n            var complete = Vector3.TransformCoordinates(afterRotZ, rotationY);\r\n\r\n            var vertex = complete.multiply(radius);\r\n            var normal = complete.divide(radius).normalize();\r\n\r\n            positions.push(vertex.x, vertex.y, vertex.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(normalizedY, normalizedZ);\r\n        }\r\n\r\n        if (zRotationStep > 0) {\r\n            var verticesCount = positions.length / 3;\r\n            for (var firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); (firstIndex + totalYRotationSteps + 2) < verticesCount; firstIndex++) {\r\n                if (dedupTopBottomIndices) {\r\n                    if (zRotationStep > 1) {\r\n                        indices.push((firstIndex));\r\n                        indices.push((firstIndex + 1));\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    }\r\n                    if (zRotationStep < totalZRotationSteps || slice < 1.0) {\r\n                        indices.push((firstIndex + totalYRotationSteps + 1));\r\n                        indices.push((firstIndex + 1));\r\n                        indices.push((firstIndex + totalYRotationSteps + 2));\r\n                    }\r\n                }\r\n                else {\r\n                    indices.push(firstIndex);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 2);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n};\r\n\r\nMesh.CreateSphere = (name: string, segments: number, diameter: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    var options = {\r\n        segments: segments,\r\n        diameterX: diameter,\r\n        diameterY: diameter,\r\n        diameterZ: diameter,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n\r\n    return SphereBuilder.CreateSphere(name, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class SphereBuilder {\r\n    /**\r\n     * Creates a sphere mesh\r\n     * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\r\n     * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\r\n     * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\r\n     * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\r\n     * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the sphere mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#sphere\r\n     */\r\n    public static CreateSphere(name: string, options: { segments?: number, diameter?: number, diameterX?: number, diameterY?: number, diameterZ?: number, arc?: number, slice?: number, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, updatable?: boolean }, scene: Nullable<Scene> = null): Mesh {\r\n        var sphere = new Mesh(name, scene);\r\n\r\n        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        sphere._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n        var vertexData = VertexData.CreateSphere(options);\r\n\r\n        vertexData.applyToMesh(sphere, options.updatable);\r\n\r\n        return sphere;\r\n    }\r\n}\r\n","import { Scene } from \"../scene\";\r\nimport { Vector3, Vector2, TmpVectors, Vector4 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\n\r\nMesh._GroundMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return GroundMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Mesh representing the gorund\r\n */\r\nexport class GroundMesh extends Mesh {\r\n    /** If octree should be generated */\r\n    public generateOctree = false;\r\n\r\n    private _heightQuads: { slope: Vector2; facet1: Vector4; facet2: Vector4 }[];\r\n\r\n    /** @hidden */\r\n    public _subdivisionsX: number;\r\n    /** @hidden */\r\n    public _subdivisionsY: number;\r\n    /** @hidden */\r\n    public _width: number;\r\n    /** @hidden */\r\n    public _height: number;\r\n    /** @hidden */\r\n    public _minX: number;\r\n    /** @hidden */\r\n    public _maxX: number;\r\n    /** @hidden */\r\n    public _minZ: number;\r\n    /** @hidden */\r\n    public _maxZ: number;\r\n\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    /**\r\n     * \"GroundMesh\"\r\n     * @returns \"GroundMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"GroundMesh\";\r\n    }\r\n\r\n    /**\r\n     * The minimum of x and y subdivisions\r\n     */\r\n    public get subdivisions(): number {\r\n        return Math.min(this._subdivisionsX, this._subdivisionsY);\r\n    }\r\n\r\n    /**\r\n     * X subdivisions\r\n     */\r\n    public get subdivisionsX(): number {\r\n        return this._subdivisionsX;\r\n    }\r\n\r\n    /**\r\n     * Y subdivisions\r\n     */\r\n    public get subdivisionsY(): number {\r\n        return this._subdivisionsY;\r\n    }\r\n\r\n    /**\r\n     * This function will update an octree to help to select the right submeshes for rendering, picking and collision computations.\r\n     * Please note that you must have a decent number of submeshes to get performance improvements when using an octree\r\n     * @param chunksCount the number of subdivisions for x and y\r\n     * @param octreeBlocksSize (Default: 32)\r\n     */\r\n    public optimize(chunksCount: number, octreeBlocksSize = 32): void {\r\n        this._subdivisionsX = chunksCount;\r\n        this._subdivisionsY = chunksCount;\r\n        this.subdivide(chunksCount);\r\n\r\n        // Call the octree system optimization if it is defined.\r\n        const thisAsAny = this as any;\r\n        if (thisAsAny.createOrUpdateSubmeshesOctree) {\r\n            thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a height (y) value in the Worl system :\r\n     * the ground altitude at the coordinates (x, z) expressed in the World system.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @returns the ground y position if (x, z) are outside the ground surface.\r\n     */\r\n    public getHeightAtCoordinates(x: number, z: number): number {\r\n        var world = this.getWorldMatrix();\r\n        var invMat = TmpVectors.Matrix[5];\r\n        world.invertToRef(invMat);\r\n        var tmpVect = TmpVectors.Vector3[8];\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, invMat, tmpVect); // transform x,z in the mesh local space\r\n        x = tmpVect.x;\r\n        z = tmpVect.z;\r\n        if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\r\n            return this.position.y;\r\n        }\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n            this._computeHeightQuads();\r\n        }\r\n        var facet = this._getFacetAt(x, z);\r\n        var y = -(facet.x * x + facet.z * z + facet.w) / facet.y;\r\n        // return y in the World system\r\n        Vector3.TransformCoordinatesFromFloatsToRef(0.0, y, 0.0, world, tmpVect);\r\n        return tmpVect.y;\r\n    }\r\n\r\n    /**\r\n     * Returns a normalized vector (Vector3) orthogonal to the ground\r\n     * at the ground coordinates (x, z) expressed in the World system.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.\r\n     */\r\n    public getNormalAtCoordinates(x: number, z: number): Vector3 {\r\n        var normal = new Vector3(0.0, 1.0, 0.0);\r\n        this.getNormalAtCoordinatesToRef(x, z, normal);\r\n        return normal;\r\n    }\r\n\r\n    /**\r\n     * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground\r\n     * at the ground coordinates (x, z) expressed in the World system.\r\n     * Doesn't uptade the reference Vector3 if (x, z) are outside the ground surface.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @param ref vector to store the result\r\n     * @returns the GroundMesh.\r\n     */\r\n    public getNormalAtCoordinatesToRef(x: number, z: number, ref: Vector3): GroundMesh {\r\n        var world = this.getWorldMatrix();\r\n        var tmpMat = TmpVectors.Matrix[5];\r\n        world.invertToRef(tmpMat);\r\n        var tmpVect = TmpVectors.Vector3[8];\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, tmpMat, tmpVect); // transform x,z in the mesh local space\r\n        x = tmpVect.x;\r\n        z = tmpVect.z;\r\n        if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\r\n            return this;\r\n        }\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n            this._computeHeightQuads();\r\n        }\r\n        var facet = this._getFacetAt(x, z);\r\n        Vector3.TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n    * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()\r\n    * if the ground has been updated.\r\n    * This can be used in the render loop.\r\n    * @returns the GroundMesh.\r\n    */\r\n    public updateCoordinateHeights(): GroundMesh {\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n        }\r\n        this._computeHeightQuads();\r\n        return this;\r\n    }\r\n\r\n    // Returns the element \"facet\" from the heightQuads array relative to (x, z) local coordinates\r\n    private _getFacetAt(x: number, z: number): Vector4 {\r\n        // retrieve col and row from x, z coordinates in the ground local system\r\n        var col = Math.floor((x + this._maxX) * this._subdivisionsX / this._width);\r\n        var row = Math.floor(-(z + this._maxZ) * this._subdivisionsY / this._height + this._subdivisionsY);\r\n        var quad = this._heightQuads[row * this._subdivisionsX + col];\r\n        var facet;\r\n        if (z < quad.slope.x * x + quad.slope.y) {\r\n            facet = quad.facet1;\r\n        } else {\r\n            facet = quad.facet2;\r\n        }\r\n        return facet;\r\n    }\r\n\r\n    //  Creates and populates the heightMap array with \"facet\" elements :\r\n    // a quad is two triangular facets separated by a slope, so a \"facet\" element is 1 slope + 2 facets\r\n    // slope : Vector2(c, h) = 2D diagonal line equation setting appart two triangular facets in a quad : z = cx + h\r\n    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\r\n    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\r\n    // Returns the GroundMesh.\r\n    private _initHeightQuads(): GroundMesh {\r\n        var subdivisionsX = this._subdivisionsX;\r\n        var subdivisionsY = this._subdivisionsY;\r\n        this._heightQuads = new Array();\r\n        for (var row = 0; row < subdivisionsY; row++) {\r\n            for (var col = 0; col < subdivisionsX; col++) {\r\n                var quad = { slope: Vector2.Zero(), facet1: new Vector4(0.0, 0.0, 0.0, 0.0), facet2: new Vector4(0.0, 0.0, 0.0, 0.0) };\r\n                this._heightQuads[row * subdivisionsX + col] = quad;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // Compute each quad element values and update the the heightMap array :\r\n    // slope : Vector2(c, h) = 2D diagonal line equation setting appart two triangular facets in a quad : z = cx + h\r\n    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\r\n    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\r\n    // Returns the GroundMesh.\r\n    private _computeHeightQuads(): GroundMesh {\r\n        var positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n        if (!positions) {\r\n            return this;\r\n        }\r\n\r\n        var v1 = TmpVectors.Vector3[3];\r\n        var v2 = TmpVectors.Vector3[2];\r\n        var v3 = TmpVectors.Vector3[1];\r\n        var v4 = TmpVectors.Vector3[0];\r\n        var v1v2 = TmpVectors.Vector3[4];\r\n        var v1v3 = TmpVectors.Vector3[5];\r\n        var v1v4 = TmpVectors.Vector3[6];\r\n        var norm1 = TmpVectors.Vector3[7];\r\n        var norm2 = TmpVectors.Vector3[8];\r\n        var i = 0;\r\n        var j = 0;\r\n        var k = 0;\r\n        var cd = 0;     // 2D slope coefficient : z = cd * x + h\r\n        var h = 0;\r\n        var d1 = 0;     // facet plane equation : ax + by + cz + d = 0\r\n        var d2 = 0;\r\n\r\n        var subdivisionsX = this._subdivisionsX;\r\n        var subdivisionsY = this._subdivisionsY;\r\n\r\n        for (var row = 0; row < subdivisionsY; row++) {\r\n            for (var col = 0; col < subdivisionsX; col++) {\r\n                i = col * 3;\r\n                j = row * (subdivisionsX + 1) * 3;\r\n                k = (row + 1) * (subdivisionsX + 1) * 3;\r\n                v1.x = positions[j + i];\r\n                v1.y = positions[j + i + 1];\r\n                v1.z = positions[j + i + 2];\r\n                v2.x = positions[j + i + 3];\r\n                v2.y = positions[j + i + 4];\r\n                v2.z = positions[j + i + 5];\r\n                v3.x = positions[k + i];\r\n                v3.y = positions[k + i + 1];\r\n                v3.z = positions[k + i + 2];\r\n                v4.x = positions[k + i + 3];\r\n                v4.y = positions[k + i + 4];\r\n                v4.z = positions[k + i + 5];\r\n\r\n                // 2D slope V1V4\r\n                cd = (v4.z - v1.z) / (v4.x - v1.x);\r\n                h = v1.z - cd * v1.x;             // v1 belongs to the slope\r\n\r\n                // facet equations :\r\n                // we compute each facet normal vector\r\n                // the equation of the facet plane is : norm.x * x + norm.y * y + norm.z * z + d = 0\r\n                // we compute the value d by applying the equation to v1 which belongs to the plane\r\n                // then we store the facet equation in a Vector4\r\n                v2.subtractToRef(v1, v1v2);\r\n                v3.subtractToRef(v1, v1v3);\r\n                v4.subtractToRef(v1, v1v4);\r\n                Vector3.CrossToRef(v1v4, v1v3, norm1);  // caution : CrossToRef uses the Tmp class\r\n                Vector3.CrossToRef(v1v2, v1v4, norm2);\r\n                norm1.normalize();\r\n                norm2.normalize();\r\n                d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);\r\n                d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);\r\n\r\n                var quad = this._heightQuads[row * subdivisionsX + col];\r\n                quad.slope.copyFromFloats(cd, h);\r\n                quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);\r\n                quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Serializes this ground mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.subdivisionsX = this._subdivisionsX;\r\n        serializationObject.subdivisionsY = this._subdivisionsY;\r\n\r\n        serializationObject.minX = this._minX;\r\n        serializationObject.maxX = this._maxX;\r\n\r\n        serializationObject.minZ = this._minZ;\r\n        serializationObject.maxZ = this._maxZ;\r\n\r\n        serializationObject.width = this._width;\r\n        serializationObject.height = this._height;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ground mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the ground mesh in\r\n     * @returns the created ground mesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): GroundMesh {\r\n        var result = new GroundMesh(parsedMesh.name, scene);\r\n\r\n        result._subdivisionsX = parsedMesh.subdivisionsX || 1;\r\n        result._subdivisionsY = parsedMesh.subdivisionsY || 1;\r\n\r\n        result._minX = parsedMesh.minX;\r\n        result._maxX = parsedMesh.maxX;\r\n\r\n        result._minZ = parsedMesh.minZ;\r\n        result._maxZ = parsedMesh.maxZ;\r\n\r\n        result._width = parsedMesh.width;\r\n        result._height = parsedMesh.height;\r\n\r\n        return result;\r\n    }\r\n}\r\n","import { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color3 } from '../../Maths/math.color';\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { GroundMesh } from \"../groundMesh\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { Nullable } from '../../types';\r\nimport { EngineStore } from '../../Engines/engineStore';\r\nimport { Epsilon } from '../../Maths/math.constants';\r\nimport { CanvasGenerator } from '../../Misc/canvasGenerator';\r\n\r\nVertexData.CreateGround = function(options: { width?: number, height?: number, subdivisions?: number, subdivisionsX?: number, subdivisionsY?: number }): VertexData {\r\n    var indices = [];\r\n    var positions = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    var row: number, col: number;\r\n\r\n    var width: number = options.width || 1;\r\n    var height: number = options.height || 1;\r\n    var subdivisionsX: number = options.subdivisionsX || options.subdivisions || 1;\r\n    var subdivisionsY: number = options.subdivisionsY || options.subdivisions || 1;\r\n\r\n    for (row = 0; row <= subdivisionsY; row++) {\r\n        for (col = 0; col <= subdivisionsX; col++) {\r\n            var position = new Vector3((col * width) / subdivisionsX - (width / 2.0), 0, ((subdivisionsY - row) * height) / subdivisionsY - (height / 2.0));\r\n            var normal = new Vector3(0, 1.0, 0);\r\n\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(col / subdivisionsX, 1.0 - row / subdivisionsY);\r\n        }\r\n    }\r\n\r\n    for (row = 0; row < subdivisionsY; row++) {\r\n        for (col = 0; col < subdivisionsX; col++) {\r\n            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + 1 + row * (subdivisionsX + 1));\r\n            indices.push(col + row * (subdivisionsX + 1));\r\n\r\n            indices.push(col + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + row * (subdivisionsX + 1));\r\n        }\r\n    }\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n};\r\n\r\nVertexData.CreateTiledGround = function(options: { xmin: number, zmin: number, xmax: number, zmax: number, subdivisions?: { w: number; h: number; }, precision?: { w: number; h: number; } }): VertexData {\r\n    var xmin = (options.xmin !== undefined && options.xmin !== null) ? options.xmin : -1.0;\r\n    var zmin = (options.zmin !== undefined && options.zmin !== null) ? options.zmin : -1.0;\r\n    var xmax = (options.xmax !== undefined && options.xmax !== null) ? options.xmax : 1.0;\r\n    var zmax = (options.zmax !== undefined && options.zmax !== null) ? options.zmax : 1.0;\r\n    var subdivisions = options.subdivisions || { w: 1, h: 1 };\r\n    var precision = options.precision || { w: 1, h: 1 };\r\n\r\n    var indices = new Array<number>();\r\n    var positions = new Array<number>();\r\n    var normals = new Array<number>();\r\n    var uvs = new Array<number>();\r\n    var row: number, col: number, tileRow: number, tileCol: number;\r\n\r\n    subdivisions.h = (subdivisions.h < 1) ? 1 : subdivisions.h;\r\n    subdivisions.w = (subdivisions.w < 1) ? 1 : subdivisions.w;\r\n    precision.w = (precision.w < 1) ? 1 : precision.w;\r\n    precision.h = (precision.h < 1) ? 1 : precision.h;\r\n\r\n    var tileSize = {\r\n        'w': (xmax - xmin) / subdivisions.w,\r\n        'h': (zmax - zmin) / subdivisions.h\r\n    };\r\n\r\n    function applyTile(xTileMin: number, zTileMin: number, xTileMax: number, zTileMax: number) {\r\n        // Indices\r\n        var base = positions.length / 3;\r\n        var rowLength = precision.w + 1;\r\n        for (row = 0; row < precision.h; row++) {\r\n            for (col = 0; col < precision.w; col++) {\r\n                var square = [\r\n                    base + col + row * rowLength,\r\n                    base + (col + 1) + row * rowLength,\r\n                    base + (col + 1) + (row + 1) * rowLength,\r\n                    base + col + (row + 1) * rowLength\r\n                ];\r\n\r\n                indices.push(square[1]);\r\n                indices.push(square[2]);\r\n                indices.push(square[3]);\r\n                indices.push(square[0]);\r\n                indices.push(square[1]);\r\n                indices.push(square[3]);\r\n            }\r\n        }\r\n\r\n        // Position, normals and uvs\r\n        var position = Vector3.Zero();\r\n        var normal = new Vector3(0, 1.0, 0);\r\n        for (row = 0; row <= precision.h; row++) {\r\n            position.z = (row * (zTileMax - zTileMin)) / precision.h + zTileMin;\r\n            for (col = 0; col <= precision.w; col++) {\r\n                position.x = (col * (xTileMax - xTileMin)) / precision.w + xTileMin;\r\n                position.y = 0;\r\n\r\n                positions.push(position.x, position.y, position.z);\r\n                normals.push(normal.x, normal.y, normal.z);\r\n                uvs.push(col / precision.w, row / precision.h);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {\r\n        for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {\r\n            applyTile(\r\n                xmin + tileCol * tileSize.w,\r\n                zmin + tileRow * tileSize.h,\r\n                xmin + (tileCol + 1) * tileSize.w,\r\n                zmin + (tileRow + 1) * tileSize.h\r\n            );\r\n        }\r\n    }\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n};\r\n\r\nVertexData.CreateGroundFromHeightMap = function(options: { width: number, height: number, subdivisions: number, minHeight: number, maxHeight: number, colorFilter: Color3, buffer: Uint8Array, bufferWidth: number, bufferHeight: number, alphaFilter: number }): VertexData {\r\n    var indices = [];\r\n    var positions = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    var row, col;\r\n    var filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\r\n    var alphaFilter = options.alphaFilter || 0.0;\r\n    var invert = false;\r\n\r\n    if (options.minHeight > options.maxHeight) {\r\n        invert = true;\r\n        let temp = options.maxHeight;\r\n        options.maxHeight = options.minHeight;\r\n        options.minHeight = temp;\r\n    }\r\n\r\n    // Vertices\r\n    for (row = 0; row <= options.subdivisions; row++) {\r\n        for (col = 0; col <= options.subdivisions; col++) {\r\n            var position = new Vector3((col * options.width) / options.subdivisions - (options.width / 2.0), 0, ((options.subdivisions - row) * options.height) / options.subdivisions - (options.height / 2.0));\r\n\r\n            // Compute height\r\n            var heightMapX = (((position.x + options.width / 2) / options.width) * (options.bufferWidth - 1)) | 0;\r\n            var heightMapY = ((1.0 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1)) | 0;\r\n\r\n            var pos = (heightMapX + heightMapY * options.bufferWidth) * 4;\r\n            var r = options.buffer[pos] / 255.0;\r\n            var g = options.buffer[pos + 1] / 255.0;\r\n            var b = options.buffer[pos + 2] / 255.0;\r\n            var a = options.buffer[pos + 3] / 255.0;\r\n\r\n            if (invert) {\r\n                r = 1.0 - r;\r\n                g = 1.0 - g;\r\n                b = 1.0 - b;\r\n            }\r\n\r\n            var gradient = r * filter.r + g * filter.g + b * filter.b;\r\n\r\n            // If our alpha channel is not within our filter then we will assign a 'special' height\r\n            // Then when building the indices, we will ignore any vertex that is using the special height\r\n            if (a >= alphaFilter) {\r\n                position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;\r\n            }\r\n            else {\r\n                position.y = options.minHeight - Epsilon; // We can't have a height below minHeight, normally.\r\n            }\r\n\r\n            // Add  vertex\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(0, 0, 0);\r\n            uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions);\r\n        }\r\n    }\r\n\r\n    // Indices\r\n    for (row = 0; row < options.subdivisions; row++) {\r\n        for (col = 0; col < options.subdivisions; col++) {\r\n            // Calculate Indices\r\n            var idx1 = (col + 1 + (row + 1) * (options.subdivisions + 1));\r\n            var idx2 = (col + 1 + row * (options.subdivisions + 1));\r\n            var idx3 = (col + row * (options.subdivisions + 1));\r\n            var idx4 = (col + (row + 1) * (options.subdivisions + 1));\r\n\r\n            // Check that all indices are visible (based on our special height)\r\n            // Only display the vertex if all Indices are visible\r\n            // Positions are stored x,y,z for each vertex, hence the * 3 and + 1 for height\r\n            var isVisibleIdx1 = positions[idx1 * 3 + 1] >= options.minHeight;\r\n            var isVisibleIdx2 = positions[idx2 * 3 + 1] >= options.minHeight;\r\n            var isVisibleIdx3 = positions[idx3 * 3 + 1] >= options.minHeight;\r\n            if (isVisibleIdx1 && isVisibleIdx2 && isVisibleIdx3) {\r\n                indices.push(idx1);\r\n                indices.push(idx2);\r\n                indices.push(idx3);\r\n            }\r\n\r\n            var isVisibleIdx4 = positions[idx4 * 3 + 1] >= options.minHeight;\r\n            if (isVisibleIdx4 && isVisibleIdx1 && isVisibleIdx3) {\r\n                indices.push(idx4);\r\n                indices.push(idx1);\r\n                indices.push(idx3);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n};\r\n\r\nMesh.CreateGround = (name: string, width: number, height: number, subdivisions: number, scene?: Scene, updatable?: boolean): Mesh => {\r\n    var options = {\r\n        width: width,\r\n        height: height,\r\n        subdivisions: subdivisions,\r\n        updatable: updatable\r\n    };\r\n\r\n    return GroundBuilder.CreateGround(name, options, scene);\r\n};\r\n\r\nMesh.CreateTiledGround = (name: string, xmin: number, zmin: number, xmax: number, zmax: number, subdivisions: { w: number; h: number; }, precision: { w: number; h: number; }, scene: Scene, updatable?: boolean): Mesh => {\r\n    var options = {\r\n        xmin: xmin,\r\n        zmin: zmin,\r\n        xmax: xmax,\r\n        zmax: zmax,\r\n        subdivisions: subdivisions,\r\n        precision: precision,\r\n        updatable: updatable\r\n    };\r\n\r\n    return GroundBuilder.CreateTiledGround(name, options, scene);\r\n};\r\n\r\nMesh.CreateGroundFromHeightMap = (name: string, url: string, width: number, height: number, subdivisions: number, minHeight: number, maxHeight: number, scene: Scene, updatable?: boolean, onReady?: (mesh: GroundMesh) => void, alphaFilter?: number): GroundMesh => {\r\n    var options = {\r\n        width: width,\r\n        height: height,\r\n        subdivisions: subdivisions,\r\n        minHeight: minHeight,\r\n        maxHeight: maxHeight,\r\n        updatable: updatable,\r\n        onReady: onReady,\r\n        alphaFilter: alphaFilter\r\n    };\r\n\r\n    return GroundBuilder.CreateGroundFromHeightMap(name, url, options, scene);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class GroundBuilder {\r\n    /**\r\n     * Creates a ground mesh\r\n     * * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground\r\n     * * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the ground mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#ground\r\n     */\r\n    public static CreateGround(name: string, options: { width?: number, height?: number, subdivisions?: number, subdivisionsX?: number, subdivisionsY?: number, updatable?: boolean }, scene: any): Mesh {\r\n        var ground = new GroundMesh(name, scene);\r\n        ground._setReady(false);\r\n        ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\r\n        ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\r\n        ground._width = options.width || 1;\r\n        ground._height = options.height || 1;\r\n        ground._maxX = ground._width / 2;\r\n        ground._maxZ = ground._height / 2;\r\n        ground._minX = -ground._maxX;\r\n        ground._minZ = -ground._maxZ;\r\n\r\n        var vertexData = VertexData.CreateGround(options);\r\n\r\n        vertexData.applyToMesh(ground, options.updatable);\r\n\r\n        ground._setReady(true);\r\n\r\n        return ground;\r\n    }\r\n\r\n    /**\r\n     * Creates a tiled ground mesh\r\n     * * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates\r\n     * * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates\r\n     * * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile\r\n     * * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the tiled ground mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#tiled-ground\r\n     */\r\n    public static CreateTiledGround(name: string, options: { xmin: number, zmin: number, xmax: number, zmax: number, subdivisions?: { w: number; h: number; }, precision?: { w: number; h: number; }, updatable?: boolean }, scene: Nullable<Scene> = null): Mesh {\r\n        var tiledGround = new Mesh(name, scene);\r\n\r\n        var vertexData = VertexData.CreateTiledGround(options);\r\n\r\n        vertexData.applyToMesh(tiledGround, options.updatable);\r\n\r\n        return tiledGround;\r\n    }\r\n\r\n    /**\r\n     * Creates a ground mesh from a height map\r\n     * * The parameter `url` sets the URL of the height map image resource.\r\n     * * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.\r\n     * * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.\r\n     * * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.\r\n     * * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.\r\n     * * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.\r\n     * * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).\r\n     * * The parameter `alphaFilter` will filter any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param url defines the url to the height map\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the ground mesh\r\n     * @see https://doc.babylonjs.com/babylon101/height_map\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#ground-from-a-height-map\r\n     */\r\n    public static CreateGroundFromHeightMap(name: string, url: string, options: { width?: number, height?: number, subdivisions?: number, minHeight?: number, maxHeight?: number, colorFilter?: Color3, alphaFilter?: number, updatable?: boolean, onReady?: (mesh: GroundMesh) => void }, scene: Nullable<Scene> = null): GroundMesh {\r\n        var width = options.width || 10.0;\r\n        var height = options.height || 10.0;\r\n        var subdivisions = options.subdivisions || 1 | 0;\r\n        var minHeight = options.minHeight || 0.0;\r\n        var maxHeight = options.maxHeight || 1.0;\r\n        var filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\r\n        var alphaFilter = options.alphaFilter || 0.0;\r\n        var updatable = options.updatable;\r\n        var onReady = options.onReady;\r\n\r\n        scene = scene || EngineStore.LastCreatedScene!;\r\n\r\n        var ground = new GroundMesh(name, scene);\r\n        ground._subdivisionsX = subdivisions;\r\n        ground._subdivisionsY = subdivisions;\r\n        ground._width = width;\r\n        ground._height = height;\r\n        ground._maxX = ground._width / 2.0;\r\n        ground._maxZ = ground._height / 2.0;\r\n        ground._minX = -ground._maxX;\r\n        ground._minZ = -ground._maxZ;\r\n\r\n        ground._setReady(false);\r\n\r\n        var onload = (img: HTMLImageElement | ImageBitmap) => {\r\n            var bufferWidth = img.width;\r\n            var bufferHeight = img.height;\r\n\r\n            // Getting height map data\r\n            var canvas = CanvasGenerator.CreateCanvas(bufferWidth, bufferHeight);\r\n            var context = canvas.getContext(\"2d\");\r\n\r\n            if (!context) {\r\n                throw new Error(\"Unable to get 2d context for CreateGroundFromHeightMap\");\r\n            }\r\n\r\n            if (scene!.isDisposed) {\r\n                return;\r\n            }\r\n\r\n            context.drawImage(img, 0, 0);\r\n\r\n            // Create VertexData from map data\r\n            // Cast is due to wrong definition in lib.d.ts from ts 1.3 - https://github.com/Microsoft/TypeScript/issues/949\r\n            var buffer = <Uint8Array>(<any>context.getImageData(0, 0, bufferWidth, bufferHeight).data);\r\n            var vertexData = VertexData.CreateGroundFromHeightMap({\r\n                width: width, height: height,\r\n                subdivisions: subdivisions,\r\n                minHeight: minHeight, maxHeight: maxHeight, colorFilter: filter,\r\n                buffer: buffer, bufferWidth: bufferWidth, bufferHeight: bufferHeight,\r\n                alphaFilter: alphaFilter\r\n            });\r\n\r\n            vertexData.applyToMesh(ground, updatable);\r\n\r\n            //execute ready callback, if set\r\n            if (onReady) {\r\n                onReady(ground);\r\n            }\r\n\r\n            ground._setReady(true);\r\n        };\r\n\r\n        Tools.LoadImage(url, onload, () => { }, scene.offlineProvider);\r\n\r\n        return ground;\r\n    }\r\n}"],"sourceRoot":""}