{"version":3,"sources":["webpack:///../../../sourceES6/core/Materials/shaderMaterial.ts"],"names":["onCreatedEffectParameters","effect","subMesh","name","scene","shaderPath","options","_textures","_textureArrays","_floats","_ints","_floatsArrays","_colors3","_colors3Arrays","_colors4","_colors4Arrays","_vectors2","_vectors3","_vectors4","_matrices","_matrixArrays","_matrices3x3","_matrices2x2","_vectors2Arrays","_vectors3Arrays","_vectors4Arrays","_cachedWorldViewMatrix","_cachedWorldViewProjectionMatrix","_multiview","_shaderPath","_options","needAlphaBlending","needAlphaTesting","attributes","uniforms","uniformBuffers","samplers","defines","this","getClassName","alpha","_checkUniform","uniformName","indexOf","push","setTexture","texture","setTextureArray","textures","setFloat","value","setInt","setFloats","setColor3","setColor3Array","reduce","arr","color","toArray","length","setColor4","setColor4Array","setVector2","setVector3","setVector4","setMatrix","setMatrices","float32Array","Float32Array","index","copyToArray","setMatrix3x3","setMatrix2x2","setArray2","setArray3","setArray4","_checkCache","mesh","useInstances","_effect","isReadyForSubMesh","isReady","isFrozen","_wasPreviouslyReady","getScene","engine","getEngine","checkReadyOnEveryCall","_renderId","getRenderId","attribs","fallbacks","getCaps","multiview","activeCamera","outputRenderTarget","getViewCount","isVerticesDataPresent","ColorKind","PushAttributesForInstances","hasThinInstances","numInfluencers","useBones","computeBonesUsingShaders","skeleton","MatricesIndicesKind","MatricesWeightsKind","numBoneInfluencers","MatricesIndicesExtraKind","MatricesWeightsExtraKind","addCPUSkinningFallback","isUsingTextureForMatrices","bones","_shouldTurnAlphaTestOn","shaderName","customShaderNameResolve","slice","previousEffect","join","_cachedDefines","createEffect","uniformsNames","uniformBuffersNames","onCompiled","onError","indexParameters","maxSimultaneousMorphTargets","_onEffectCreatedObservable","notifyObservers","resetCachedMaterial","bindOnlyWorldMatrix","world","effectOverride","multiplyToRef","getViewMatrix","getTransformMatrix","bindForSubMesh","bind","_effectOverride","getCachedMaterial","getProjectionMatrix","_transformMatrixR","globalPosition","BindBonesParameters","setArray","setFloat4","r","g","b","a","seffect","_afterBind","_cachedEffect","getActiveTextures","activeTextures","array","hasTexture","clone","result","Clone","ShaderMaterial","key","id","Object","keys","forEach","propName","propValue","Array","isArray","dispose","forceDisposeEffect","forceDisposeTextures","notBoundToMesh","serialize","serializationObject","Serialize","customType","textureArrays","floats","FloatArrays","colors3","asArray","colors3Arrays","colors4","colors4Arrays","vectors2","vectors3","vectors4","matrices","matrixArray","matrices3x3","matrices2x2","vectors2Arrays","vectors3Arrays","vectors4Arrays","Parse","source","rootUrl","material","textureArray","floatsArrays","FromArray","colors","num","i","map","ParseFromFileAsync","url","Promise","resolve","reject","request","addEventListener","readyState","status","JSON","parse","responseText","output","LastCreatedScene","open","send","CreateFromSnippetAsync","snippetId","snippet","jsonPayload","shaderMaterial","SnippetUrl","replace","RegisteredTypes"],"mappings":"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","file":"js/2.babylonBundle.js","sourcesContent":["import { SerializationHelper } from \"../Misc/decorators\";\r\nimport { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix, Vector3, Vector2, Vector4 } from \"../Maths/math.vector\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { MaterialHelper } from \"./materialHelper\";\r\nimport { Effect, IEffectCreationOptions } from \"./effect\";\r\nimport { Material } from \"./material\";\r\nimport { _TypeStore } from '../Misc/typeStore';\r\nimport { Color3, Color4 } from '../Maths/math.color';\r\nimport { EffectFallbacks } from './effectFallbacks';\r\nimport { WebRequest } from '../Misc/webRequest';\r\nimport { Engine } from '../Engines/engine';\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\n/**\r\n * Defines the options associated with the creation of a shader material.\r\n */\r\nexport interface IShaderMaterialOptions {\r\n    /**\r\n     * Does the material work in alpha blend mode\r\n     */\r\n    needAlphaBlending: boolean;\r\n\r\n    /**\r\n     * Does the material work in alpha test mode\r\n     */\r\n    needAlphaTesting: boolean;\r\n\r\n    /**\r\n     * The list of attribute names used in the shader\r\n     */\r\n    attributes: string[];\r\n\r\n    /**\r\n     * The list of unifrom names used in the shader\r\n     */\r\n    uniforms: string[];\r\n\r\n    /**\r\n     * The list of UBO names used in the shader\r\n     */\r\n    uniformBuffers: string[];\r\n\r\n    /**\r\n     * The list of sampler names used in the shader\r\n     */\r\n    samplers: string[];\r\n\r\n    /**\r\n     * The list of defines used in the shader\r\n     */\r\n    defines: string[];\r\n}\r\n\r\n/**\r\n * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n *\r\n * This returned material effects how the mesh will look based on the code in the shaders.\r\n *\r\n * @see https://doc.babylonjs.com/how_to/shader_material\r\n */\r\nexport class ShaderMaterial extends Material {\r\n    private _shaderPath: any;\r\n    private _options: IShaderMaterialOptions;\r\n    private _textures: { [name: string]: BaseTexture } = {};\r\n    private _textureArrays: { [name: string]: BaseTexture[] } = {};\r\n    private _floats: { [name: string]: number } = {};\r\n    private _ints: { [name: string]: number } = {};\r\n    private _floatsArrays: { [name: string]: number[] } = {};\r\n    private _colors3: { [name: string]: Color3 } = {};\r\n    private _colors3Arrays: { [name: string]: number[] } = {};\r\n    private _colors4: { [name: string]: Color4 } = {};\r\n    private _colors4Arrays: { [name: string]: number[] } = {};\r\n    private _vectors2: { [name: string]: Vector2 } = {};\r\n    private _vectors3: { [name: string]: Vector3 } = {};\r\n    private _vectors4: { [name: string]: Vector4 } = {};\r\n    private _matrices: { [name: string]: Matrix } = {};\r\n    private _matrixArrays: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _matrices3x3: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _matrices2x2: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _vectors2Arrays: { [name: string]: number[] } = {};\r\n    private _vectors3Arrays: { [name: string]: number[] } = {};\r\n    private _vectors4Arrays: { [name: string]: number[] } = {};\r\n    private _cachedWorldViewMatrix = new Matrix();\r\n    private _cachedWorldViewProjectionMatrix = new Matrix();\r\n    private _renderId: number;\r\n    private _multiview: boolean = false;\r\n    private _cachedDefines: string;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = \"https://snippet.babylonjs.com\";\r\n\r\n    /** Snippet ID if the material was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Instantiate a new shader material.\r\n     * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n     * This returned material effects how the mesh will look based on the code in the shaders.\r\n     * @see https://doc.babylonjs.com/how_to/shader_material\r\n     * @param name Define the name of the material in the scene\r\n     * @param scene Define the scene the material belongs to\r\n     * @param shaderPath Defines  the route to the shader code in one of three ways:\r\n     *  * object: { vertex: \"custom\", fragment: \"custom\" }, used with Effect.ShadersStore[\"customVertexShader\"] and Effect.ShadersStore[\"customFragmentShader\"]\r\n     *  * object: { vertexElement: \"vertexShaderCode\", fragmentElement: \"fragmentShaderCode\" }, used with shader code in script tags\r\n     *  * object: { vertexSource: \"vertex shader code string\", fragmentSource: \"fragment shader code string\" } using with strings containing the shaders code\r\n     *  * string: \"./COMMON_NAME\", used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.\r\n     * @param options Define the options used to create the shader\r\n     */\r\n    constructor(name: string, scene: Scene, shaderPath: any, options: Partial<IShaderMaterialOptions> = {}) {\r\n        super(name, scene);\r\n        this._shaderPath = shaderPath;\r\n\r\n        this._options = {\r\n            needAlphaBlending: false,\r\n            needAlphaTesting: false,\r\n            attributes: [\"position\", \"normal\", \"uv\"],\r\n            uniforms: [\"worldViewProjection\"],\r\n            uniformBuffers: [],\r\n            samplers: [],\r\n            defines: [],\r\n            ...options\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\r\n    public get shaderPath(): any {\r\n        return this._shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Sets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\r\n    public set shaderPath(shaderPath: any) {\r\n        this._shaderPath = shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Gets the options used to compile the shader.\r\n     * They can be modified to trigger a new compilation\r\n     */\r\n    public get options(): IShaderMaterialOptions {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"ShaderMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ShaderMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        return (this.alpha < 1.0) || this._options.needAlphaBlending;\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        return this._options.needAlphaTesting;\r\n    }\r\n\r\n    private _checkUniform(uniformName: string): void {\r\n        if (this._options.uniforms.indexOf(uniformName) === -1) {\r\n            this._options.uniforms.push(uniformName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the shader.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTexture(name: string, texture: BaseTexture): ShaderMaterial {\r\n        if (this._options.samplers.indexOf(name) === -1) {\r\n            this._options.samplers.push(name);\r\n        }\r\n        this._textures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a texture array in the shader.\r\n     * @param name Define the name of the uniform sampler array as defined in the shader\r\n     * @param textures Define the list of textures to bind to this sampler\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTextureArray(name: string, textures: BaseTexture[]): ShaderMaterial {\r\n        if (this._options.samplers.indexOf(name) === -1) {\r\n            this._options.samplers.push(name);\r\n        }\r\n\r\n        this._checkUniform(name);\r\n\r\n        this._textureArrays[name] = textures;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloat(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._floats[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setInt(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._ints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an array of floats in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloats(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._floatsArrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Color3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3(name: string, value: Color3): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 array in the shader from a Color3 array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3Array(name: string, value: Color3[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors3Arrays[name] = value.reduce((arr, color) => {\r\n            color.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Color4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4(name: string, value: Color4): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a Color4 array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4Array(name: string, value: Color4[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors4Arrays[name] = value.reduce((arr, color) => {\r\n            color.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 in the shader from a Vector2.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector2(name: string, value: Vector2): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Vector3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector3(name: string, value: Vector3): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Vector4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector4(name: string, value: Vector4): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat4 in the shader from a Matrix.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix(name: string, value: Matrix): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float32Array in the shader from a matrix array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrices(name: string, value: Matrix[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n\r\n        let float32Array = new Float32Array(value.length * 16);\r\n\r\n        for (var index = 0; index < value.length; index++) {\r\n            let matrix = value[index];\r\n\r\n            matrix.copyToArray(float32Array, index * 16);\r\n        }\r\n\r\n        this._matrixArrays[name] = float32Array;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat3 in the shader from a Float32Array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix3x3(name: string, value: Float32Array | Array<number>): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices3x3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat2 in the shader from a Float32Array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix2x2(name: string, value: Float32Array | Array<number>): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices2x2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray2(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors2Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray3(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors3Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray4(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors4Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    private _checkCache(mesh?: AbstractMesh, useInstances?: boolean): boolean {\r\n        if (!mesh) {\r\n            return true;\r\n        }\r\n\r\n        if (this._effect && (this._effect.defines.indexOf(\"#define INSTANCES\") !== -1) !== useInstances) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        return this.isReady(mesh, useInstances);\r\n    }\r\n\r\n    /**\r\n     * Checks if the material is ready to render the requested mesh\r\n     * @param mesh Define the mesh to render\r\n     * @param useInstances Define whether or not the material is used with instances\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    public isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean {\r\n        if (this._effect && this.isFrozen) {\r\n            if (this._effect._wasPreviouslyReady) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        var scene = this.getScene();\r\n        var engine = scene.getEngine();\r\n\r\n        if (!this.checkReadyOnEveryCall) {\r\n            if (this._renderId === scene.getRenderId()) {\r\n                if (this._checkCache(mesh, useInstances)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Instances\r\n        var defines = [];\r\n        var attribs = [];\r\n        var fallbacks = new EffectFallbacks();\r\n\r\n        // global multiview\r\n        if (engine.getCaps().multiview &&\r\n            scene.activeCamera &&\r\n            scene.activeCamera.outputRenderTarget &&\r\n            scene.activeCamera.outputRenderTarget.getViewCount() > 1) {\r\n            this._multiview = true;\r\n            defines.push(\"#define MULTIVIEW\");\r\n            if (this._options.uniforms.indexOf(\"viewProjection\") !== -1 &&\r\n                this._options.uniforms.push(\"viewProjectionR\") === -1) {\r\n                this._options.uniforms.push(\"viewProjectionR\");\r\n            }\r\n        }\r\n\r\n        for (var index = 0; index < this._options.defines.length; index++) {\r\n            defines.push(this._options.defines[index]);\r\n        }\r\n\r\n        for (var index = 0; index < this._options.attributes.length; index++) {\r\n            attribs.push(this._options.attributes[index]);\r\n        }\r\n\r\n        if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            attribs.push(VertexBuffer.ColorKind);\r\n            defines.push(\"#define VERTEXCOLOR\");\r\n        }\r\n\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs);\r\n            if (mesh?.hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // Bones\r\n        let numInfluencers = 0;\r\n        if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n\r\n            const skeleton = mesh.skeleton;\r\n\r\n            numInfluencers = mesh.numBoneInfluencers;\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + numInfluencers);\r\n            fallbacks.addCPUSkinningFallback(0, mesh);\r\n\r\n            if (skeleton.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n\r\n                if (this._options.uniforms.indexOf(\"boneTextureWidth\") === -1) {\r\n                    this._options.uniforms.push(\"boneTextureWidth\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"boneSampler\") === -1) {\r\n                    this._options.samplers.push(\"boneSampler\");\r\n                }\r\n            } else {\r\n                defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\r\n\r\n                if (this._options.uniforms.indexOf(\"mBones\") === -1) {\r\n                    this._options.uniforms.push(\"mBones\");\r\n                }\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Textures\r\n        for (var name in this._textures) {\r\n            if (!this._textures[name].isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Alpha test\r\n        if (mesh && this._shouldTurnAlphaTestOn(mesh)) {\r\n            defines.push(\"#define ALPHATEST\");\r\n        }\r\n\r\n        let shaderName = this._shaderPath,\r\n            uniforms = this._options.uniforms,\r\n            uniformBuffers = this._options.uniformBuffers,\r\n            samplers = this._options.samplers;\r\n\r\n        if (this.customShaderNameResolve) {\r\n            uniforms = uniforms.slice();\r\n            uniformBuffers = uniformBuffers.slice();\r\n            samplers = samplers.slice();\r\n            shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs);\r\n        }\r\n\r\n        var previousEffect = this._effect;\r\n        var join = defines.join(\"\\n\");\r\n\r\n        if (this._cachedDefines !== join) {\r\n            this._cachedDefines = join;\r\n\r\n            this._effect = engine.createEffect(shaderName, <IEffectCreationOptions>{\r\n                attributes: attribs,\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: join,\r\n                fallbacks: fallbacks,\r\n                onCompiled: this.onCompiled,\r\n                onError: this.onError,\r\n                indexParameters: { maxSimultaneousMorphTargets: numInfluencers }\r\n            }, engine);\r\n\r\n            if (this._onEffectCreatedObservable) {\r\n                onCreatedEffectParameters.effect = this._effect;\r\n                this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n            }\r\n        }\r\n\r\n        if (!this._effect?.isReady() ?? true) {\r\n            return false;\r\n        }\r\n\r\n        if (previousEffect !== this._effect) {\r\n            scene.resetCachedMaterial();\r\n        }\r\n\r\n        this._renderId = scene.getRenderId();\r\n        this._effect._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     * @param effectOverride - If provided, use this effect instead of internal effect\r\n     */\r\n    public bindOnlyWorldMatrix(world: Matrix, effectOverride?: Nullable<Effect>): void {\r\n        var scene = this.getScene();\r\n\r\n        const effect = effectOverride ?? this._effect;\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"world\") !== -1) {\r\n            effect.setMatrix(\"world\", world);\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"worldView\") !== -1) {\r\n            world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\r\n            effect.setMatrix(\"worldView\", this._cachedWorldViewMatrix);\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"worldViewProjection\") !== -1) {\r\n            world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\r\n            effect.setMatrix(\"worldViewProjection\", this._cachedWorldViewProjectionMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        this.bind(world, mesh, subMesh._effectOverride);\r\n    }\r\n\r\n    /**\r\n     * Binds the material to the mesh\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh to bind the material to\r\n     * @param effectOverride - If provided, use this effect instead of internal effect\r\n     */\r\n    public bind(world: Matrix, mesh?: Mesh, effectOverride?: Nullable<Effect>): void {\r\n        // Std values\r\n        this.bindOnlyWorldMatrix(world, effectOverride);\r\n\r\n        const effect = effectOverride ?? this._effect;\r\n\r\n        if (effect && this.getScene().getCachedMaterial() !== this) {\r\n            if (this._options.uniforms.indexOf(\"view\") !== -1) {\r\n                effect.setMatrix(\"view\", this.getScene().getViewMatrix());\r\n            }\r\n\r\n            if (this._options.uniforms.indexOf(\"projection\") !== -1) {\r\n                effect.setMatrix(\"projection\", this.getScene().getProjectionMatrix());\r\n            }\r\n\r\n            if (this._options.uniforms.indexOf(\"viewProjection\") !== -1) {\r\n                effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\r\n                if (this._multiview) {\r\n                    effect.setMatrix(\"viewProjectionR\", this.getScene()._transformMatrixR);\r\n                }\r\n            }\r\n\r\n            if (this.getScene().activeCamera && this._options.uniforms.indexOf(\"cameraPosition\") !== -1) {\r\n                effect.setVector3(\"cameraPosition\", this.getScene().activeCamera!.globalPosition);\r\n            }\r\n\r\n            // Bones\r\n            MaterialHelper.BindBonesParameters(mesh, effect);\r\n\r\n            var name: string;\r\n            // Texture\r\n            for (name in this._textures) {\r\n                effect.setTexture(name, this._textures[name]);\r\n            }\r\n\r\n            // Texture arrays\r\n            for (name in this._textureArrays) {\r\n                effect.setTextureArray(name, this._textureArrays[name]);\r\n            }\r\n\r\n            // Int\r\n            for (name in this._ints) {\r\n                effect.setInt(name, this._ints[name]);\r\n            }\r\n\r\n            // Float\r\n            for (name in this._floats) {\r\n                effect.setFloat(name, this._floats[name]);\r\n            }\r\n\r\n            // Floats\r\n            for (name in this._floatsArrays) {\r\n                effect.setArray(name, this._floatsArrays[name]);\r\n            }\r\n\r\n            // Color3\r\n            for (name in this._colors3) {\r\n                effect.setColor3(name, this._colors3[name]);\r\n            }\r\n\r\n            // Color3Array\r\n            for (name in this._colors3Arrays) {\r\n                effect.setArray3(name, this._colors3Arrays[name]);\r\n            }\r\n\r\n            // Color4\r\n            for (name in this._colors4) {\r\n                var color = this._colors4[name];\r\n                effect.setFloat4(name, color.r, color.g, color.b, color.a);\r\n            }\r\n\r\n            // Color4Array\r\n            for (name in this._colors4Arrays) {\r\n                effect.setArray4(name, this._colors4Arrays[name]);\r\n            }\r\n\r\n            // Vector2\r\n            for (name in this._vectors2) {\r\n                effect.setVector2(name, this._vectors2[name]);\r\n            }\r\n\r\n            // Vector3\r\n            for (name in this._vectors3) {\r\n                effect.setVector3(name, this._vectors3[name]);\r\n            }\r\n\r\n            // Vector4\r\n            for (name in this._vectors4) {\r\n                effect.setVector4(name, this._vectors4[name]);\r\n            }\r\n\r\n            // Matrix\r\n            for (name in this._matrices) {\r\n                effect.setMatrix(name, this._matrices[name]);\r\n            }\r\n\r\n            // MatrixArray\r\n            for (name in this._matrixArrays) {\r\n                effect.setMatrices(name, this._matrixArrays[name]);\r\n            }\r\n\r\n            // Matrix 3x3\r\n            for (name in this._matrices3x3) {\r\n                effect.setMatrix3x3(name, this._matrices3x3[name]);\r\n            }\r\n\r\n            // Matrix 2x2\r\n            for (name in this._matrices2x2) {\r\n                effect.setMatrix2x2(name, this._matrices2x2[name]);\r\n            }\r\n\r\n            // Vector2Array\r\n            for (name in this._vectors2Arrays) {\r\n                effect.setArray2(name, this._vectors2Arrays[name]);\r\n            }\r\n\r\n            // Vector3Array\r\n            for (name in this._vectors3Arrays) {\r\n                effect.setArray3(name, this._vectors3Arrays[name]);\r\n            }\r\n\r\n            // Vector4Array\r\n            for (name in this._vectors4Arrays) {\r\n                effect.setArray4(name, this._vectors4Arrays[name]);\r\n            }\r\n        }\r\n\r\n        const seffect = this._effect;\r\n\r\n        this._effect = effect; // make sure the active effect is the right one if there are some observers for onBind that would need to get the current effect\r\n        this._afterBind(mesh);\r\n        this._effect = seffect;\r\n    }\r\n\r\n    protected _afterBind(mesh?: Mesh): void {\r\n        super._afterBind(mesh);\r\n        this.getScene()._cachedEffect = this._effect;\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        var activeTextures = super.getActiveTextures();\r\n\r\n        for (var name in this._textures) {\r\n            activeTextures.push(this._textures[name]);\r\n        }\r\n\r\n        for (var name in this._textureArrays) {\r\n            var array = this._textureArrays[name];\r\n            for (var index = 0; index < array.length; index++) {\r\n                activeTextures.push(array[index]);\r\n            }\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        for (var name in this._textures) {\r\n            if (this._textures[name] === texture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        for (var name in this._textureArrays) {\r\n            var array = this._textureArrays[name];\r\n            for (var index = 0; index < array.length; index++) {\r\n                if (array[index] === texture) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    public clone(name: string): ShaderMaterial {\r\n        var result = SerializationHelper.Clone(() => new ShaderMaterial(name, this.getScene(), this._shaderPath, this._options), this);\r\n\r\n        result.name = name;\r\n        result.id = name;\r\n\r\n        // Shader code path\r\n        if (typeof result._shaderPath === 'object') {\r\n            result._shaderPath = { ...result._shaderPath };\r\n        }\r\n\r\n        // Options\r\n        this._options = { ...this._options };\r\n\r\n        (Object.keys(this._options) as Array<keyof IShaderMaterialOptions>).forEach((propName) => {\r\n            const propValue = this._options[propName];\r\n            if (Array.isArray(propValue)) {\r\n                (<string[]>this._options[propName]) = propValue.slice(0);\r\n            }\r\n        });\r\n\r\n        // Texture\r\n        for (var key in this._textures) {\r\n            result.setTexture(key, this._textures[key]);\r\n        }\r\n\r\n        // Float\r\n        for (var key in this._floats) {\r\n            result.setFloat(key, this._floats[key]);\r\n        }\r\n\r\n        // Floats\r\n        for (var key in this._floatsArrays) {\r\n            result.setFloats(key, this._floatsArrays[key]);\r\n        }\r\n\r\n        // Color3\r\n        for (var key in this._colors3) {\r\n            result.setColor3(key, this._colors3[key]);\r\n        }\r\n\r\n        // Color4\r\n        for (var key in this._colors4) {\r\n            result.setColor4(key, this._colors4[key]);\r\n        }\r\n\r\n        // Vector2\r\n        for (var key in this._vectors2) {\r\n            result.setVector2(key, this._vectors2[key]);\r\n        }\r\n\r\n        // Vector3\r\n        for (var key in this._vectors3) {\r\n            result.setVector3(key, this._vectors3[key]);\r\n        }\r\n\r\n        // Vector4\r\n        for (var key in this._vectors4) {\r\n            result.setVector4(key, this._vectors4[key]);\r\n        }\r\n\r\n        // Matrix\r\n        for (var key in this._matrices) {\r\n            result.setMatrix(key,  this._matrices[key]);\r\n        }\r\n\r\n        // Matrix 3x3\r\n        for (var key in this._matrices3x3) {\r\n            result.setMatrix3x3(key, this._matrices3x3[key]);\r\n        }\r\n\r\n        // Matrix 2x2\r\n        for (var key in this._matrices2x2) {\r\n            result.setMatrix2x2(key, this._matrices2x2[key]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n\r\n        if (forceDisposeTextures) {\r\n            var name: string;\r\n            for (name in this._textures) {\r\n                this._textures[name].dispose();\r\n            }\r\n\r\n            for (name in this._textureArrays) {\r\n                var array = this._textureArrays[name];\r\n                for (var index = 0; index < array.length; index++) {\r\n                    array[index].dispose();\r\n                }\r\n            }\r\n        }\r\n\r\n        this._textures = {};\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\r\n    }\r\n\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.ShaderMaterial\";\r\n\r\n        serializationObject.options = this._options;\r\n        serializationObject.shaderPath = this._shaderPath;\r\n\r\n        var name: string;\r\n\r\n        // Texture\r\n        serializationObject.textures = {};\r\n        for (name in this._textures) {\r\n            serializationObject.textures[name] = this._textures[name].serialize();\r\n        }\r\n\r\n        // Texture arrays\r\n        serializationObject.textureArrays = {};\r\n        for (name in this._textureArrays) {\r\n            serializationObject.textureArrays[name] = [];\r\n            var array = this._textureArrays[name];\r\n            for (var index = 0; index < array.length; index++) {\r\n                serializationObject.textureArrays[name].push(array[index].serialize());\r\n            }\r\n        }\r\n\r\n        // Float\r\n        serializationObject.floats = {};\r\n        for (name in this._floats) {\r\n            serializationObject.floats[name] = this._floats[name];\r\n        }\r\n\r\n        // Floats\r\n        serializationObject.FloatArrays = {};\r\n        for (name in this._floatsArrays) {\r\n            serializationObject.FloatArrays[name] = this._floatsArrays[name];\r\n        }\r\n\r\n        // Color3\r\n        serializationObject.colors3 = {};\r\n        for (name in this._colors3) {\r\n            serializationObject.colors3[name] = this._colors3[name].asArray();\r\n        }\r\n\r\n        // Color3 array\r\n        serializationObject.colors3Arrays = {};\r\n        for (name in this._colors3Arrays) {\r\n            serializationObject.colors3Arrays[name] = this._colors3Arrays[name];\r\n        }\r\n\r\n        // Color4\r\n        serializationObject.colors4 = {};\r\n        for (name in this._colors4) {\r\n            serializationObject.colors4[name] = this._colors4[name].asArray();\r\n        }\r\n\r\n        // Color4 array\r\n        serializationObject.colors4Arrays = {};\r\n        for (name in this._colors4Arrays) {\r\n            serializationObject.colors4Arrays[name] = this._colors4Arrays[name];\r\n        }\r\n\r\n        // Vector2\r\n        serializationObject.vectors2 = {};\r\n        for (name in this._vectors2) {\r\n            serializationObject.vectors2[name] = this._vectors2[name].asArray();\r\n        }\r\n\r\n        // Vector3\r\n        serializationObject.vectors3 = {};\r\n        for (name in this._vectors3) {\r\n            serializationObject.vectors3[name] = this._vectors3[name].asArray();\r\n        }\r\n\r\n        // Vector4\r\n        serializationObject.vectors4 = {};\r\n        for (name in this._vectors4) {\r\n            serializationObject.vectors4[name] = this._vectors4[name].asArray();\r\n        }\r\n\r\n        // Matrix\r\n        serializationObject.matrices = {};\r\n        for (name in this._matrices) {\r\n            serializationObject.matrices[name] = this._matrices[name].asArray();\r\n        }\r\n\r\n        // MatrixArray\r\n        serializationObject.matrixArray = {};\r\n        for (name in this._matrixArrays) {\r\n            serializationObject.matrixArray[name] = this._matrixArrays[name];\r\n        }\r\n\r\n        // Matrix 3x3\r\n        serializationObject.matrices3x3 = {};\r\n        for (name in this._matrices3x3) {\r\n            serializationObject.matrices3x3[name] = this._matrices3x3[name];\r\n        }\r\n\r\n        // Matrix 2x2\r\n        serializationObject.matrices2x2 = {};\r\n        for (name in this._matrices2x2) {\r\n            serializationObject.matrices2x2[name] = this._matrices2x2[name];\r\n        }\r\n\r\n        // Vector2Array\r\n        serializationObject.vectors2Arrays = {};\r\n        for (name in this._vectors2Arrays) {\r\n            serializationObject.vectors2Arrays[name] = this._vectors2Arrays[name];\r\n        }\r\n\r\n        // Vector3Array\r\n        serializationObject.vectors3Arrays = {};\r\n        for (name in this._vectors3Arrays) {\r\n            serializationObject.vectors3Arrays[name] = this._vectors3Arrays[name];\r\n        }\r\n\r\n        // Vector4Array\r\n        serializationObject.vectors4Arrays = {};\r\n        for (name in this._vectors4Arrays) {\r\n            serializationObject.vectors4Arrays[name] = this._vectors4Arrays[name];\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a shader material from parsed shader material data\r\n     * @param source defines the JSON represnetation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new material\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): ShaderMaterial {\r\n        var material = SerializationHelper.Parse(() => new ShaderMaterial(source.name, scene, source.shaderPath, source.options), source, scene, rootUrl);\r\n\r\n        var name: string;\r\n\r\n        // Texture\r\n        for (name in source.textures) {\r\n            material.setTexture(name, <Texture>Texture.Parse(source.textures[name], scene, rootUrl));\r\n        }\r\n\r\n        // Texture arrays\r\n        for (name in source.textureArrays) {\r\n            var array = source.textureArrays[name];\r\n            var textureArray = new Array<Texture>();\r\n\r\n            for (var index = 0; index < array.length; index++) {\r\n                textureArray.push(<Texture>Texture.Parse(array[index], scene, rootUrl));\r\n            }\r\n            material.setTextureArray(name, textureArray);\r\n        }\r\n\r\n        // Float\r\n        for (name in source.floats) {\r\n            material.setFloat(name, source.floats[name]);\r\n        }\r\n\r\n        // Float s\r\n        for (name in source.floatsArrays) {\r\n            material.setFloats(name, source.floatsArrays[name]);\r\n        }\r\n\r\n        // Color3\r\n        for (name in source.colors3) {\r\n            material.setColor3(name, Color3.FromArray(source.colors3[name]));\r\n        }\r\n\r\n        // Color3 arrays\r\n        for (name in source.colors3Arrays) {\r\n            const colors: Color3[] = source.colors3Arrays[name].reduce((arr: Array<Array<number>>, num: number, i: number) => {\r\n                if (i % 3 === 0) {\r\n                    arr.push([num]);\r\n                } else {\r\n                    arr[arr.length - 1].push(num);\r\n                }\r\n                return arr;\r\n            }, []).map((color: ArrayLike<number>) => Color3.FromArray(color));\r\n            material.setColor3Array(name, colors);\r\n        }\r\n\r\n        // Color4\r\n        for (name in source.colors4) {\r\n            material.setColor4(name, Color4.FromArray(source.colors4[name]));\r\n        }\r\n\r\n        // Color4 arrays\r\n        for (name in source.colors4Arrays) {\r\n            const colors: Color4[] = source.colors4Arrays[name].reduce((arr: Array<Array<number>>, num: number, i: number) => {\r\n                if (i % 4 === 0) {\r\n                    arr.push([num]);\r\n                } else {\r\n                    arr[arr.length - 1].push(num);\r\n                }\r\n                return arr;\r\n            }, []).map((color: ArrayLike<number>) => Color4.FromArray(color));\r\n            material.setColor4Array(name, colors);\r\n        }\r\n\r\n        // Vector2\r\n        for (name in source.vectors2) {\r\n            material.setVector2(name, Vector2.FromArray(source.vectors2[name]));\r\n        }\r\n\r\n        // Vector3\r\n        for (name in source.vectors3) {\r\n            material.setVector3(name, Vector3.FromArray(source.vectors3[name]));\r\n        }\r\n\r\n        // Vector4\r\n        for (name in source.vectors4) {\r\n            material.setVector4(name, Vector4.FromArray(source.vectors4[name]));\r\n        }\r\n\r\n        // Matrix\r\n        for (name in source.matrices) {\r\n            material.setMatrix(name, Matrix.FromArray(source.matrices[name]));\r\n        }\r\n\r\n        // MatrixArray\r\n        for (name in source.matrixArray) {\r\n            material._matrixArrays[name] = new Float32Array(source.matrixArray[name]);\r\n        }\r\n\r\n        // Matrix 3x3\r\n        for (name in source.matrices3x3) {\r\n            material.setMatrix3x3(name, source.matrices3x3[name]);\r\n        }\r\n\r\n        // Matrix 2x2\r\n        for (name in source.matrices2x2) {\r\n            material.setMatrix2x2(name, source.matrices2x2[name]);\r\n        }\r\n\r\n        // Vector2Array\r\n        for (name in source.vectors2Arrays) {\r\n            material.setArray2(name, source.vectors2Arrays[name]);\r\n        }\r\n\r\n        // Vector3Array\r\n        for (name in source.vectors3Arrays) {\r\n            material.setArray3(name, source.vectors3Arrays[name]);\r\n        }\r\n\r\n        // Vector4Array\r\n        for (name in source.vectors4Arrays) {\r\n            material.setArray4(name, source.vectors4Arrays[name]);\r\n        }\r\n\r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ShaderMaterial from a snippet saved in a remote file\r\n     * @param name defines the name of the ShaderMaterial to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string, scene: Scene, rootUrl: string = \"\"): Promise<ShaderMaterial> {\r\n\r\n        return new Promise((resolve, reject) => {\r\n            var request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        let serializationObject = JSON.parse(request.responseText);\r\n                        let output = this.Parse(serializationObject, scene || Engine.LastCreatedScene, rootUrl);\r\n\r\n                        if (name) {\r\n                            output.name = name;\r\n                        }\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the ShaderMaterial\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a ShaderMaterial from a snippet saved by the Inspector\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static CreateFromSnippetAsync(snippetId: string, scene: Scene, rootUrl: string = \"\"): Promise<ShaderMaterial> {\r\n        return new Promise((resolve, reject) => {\r\n            var request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        var snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        let serializationObject = JSON.parse(snippet.shaderMaterial);\r\n                        let output = this.Parse(serializationObject, scene || Engine.LastCreatedScene, rootUrl);\r\n\r\n                        output.snippetId = snippetId;\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.ShaderMaterial\"] = ShaderMaterial;\r\n"],"sourceRoot":""}